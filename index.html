<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP CMS Core Metrics - Code Quality Dashboard</title>
    <meta name="description" content="Track PHP CMS code quality over time. See lines of code, cyclomatic complexity, maintainability index, anti-patterns, and API surface area for Drupal and TYPO3.">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --color-good: #22c55e;
            --color-warning: #f59e0b;
            --color-bad: #ef4444;
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            padding: clamp(1rem, 4vw, 2rem);
        }
        .container { max-width: 1400px; margin: 0 auto; }
        header { margin-bottom: 2rem; }
        h1 { font-size: 1.75rem; font-weight: 600; margin-bottom: 0.25rem; }
        h2 { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.25rem; }
        .header-meta { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 1.5rem; text-transform: uppercase; letter-spacing: 0.05em; }
        .executive-summary { margin: 0 0 0.75rem 0; line-height: 1.7; color: var(--text-secondary); }
        .card {
            background: var(--bg-primary);
            border-radius: 0.75rem;
            padding: clamp(1rem, 3vw, 1.5rem);
            margin-bottom: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .section-subtitle { font-size: 0.875rem; color: var(--text-secondary); margin-bottom: 0.75rem; }
        .metric-list { font-size: 0.8125rem; color: var(--text-secondary); margin: 0 0 1rem 0; padding-left: 1.25rem; line-height: 1.6; }
        .metric-list li { margin-bottom: 0.125rem; }
        .metric-list strong { color: var(--text-primary); font-weight: 500; }
        code { font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 0.9em; background: var(--bg-secondary); padding: 0.1em 0.3em; border-radius: 0.25rem; }
        .chart-container { position: relative; height: 300px; }
        .hotspots-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
        .hotspots-table th { text-align: left; padding: 0.75rem; border-bottom: 2px solid var(--border-color); font-weight: 600; color: var(--text-secondary); }
        .hotspots-table td { padding: 0.75rem; border-bottom: 1px solid var(--border-color); }
        .hotspots-table tr:hover { background: var(--bg-secondary); }
        .hotspots-table .class-name { font-family: 'SF Mono', Monaco, 'Courier New', monospace; font-size: 0.8125rem; }
        .metric-bad { color: var(--color-bad); font-weight: 600; }
        .metric-warning { color: var(--color-warning); font-weight: 600; }
        .metric-good { color: var(--color-good); }
        a { color: #2563eb; text-decoration: none; }
        a:hover { text-decoration: underline; }
        a:focus { outline: 2px solid #3b82f6; outline-offset: 2px; }
        button { cursor: pointer; border: 1px solid var(--border-color); background: var(--bg-primary); font-family: inherit; font-size: inherit; color: inherit; }
        button:focus { outline: 2px solid #3b82f6; outline-offset: 2px; }
        button:hover { background: var(--bg-secondary); }
        button.active { background: var(--text-primary); color: var(--bg-primary); border-color: var(--text-primary); }
        .toggle-button { margin-top: 1rem; padding: 0.5rem 1rem; border-radius: 0.375rem; }
        .sort-button { padding: 0.25rem 0.5rem; margin-left: 0.25rem; border-radius: 0.25rem; font-size: 0.75rem; }
        .surface-area-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1rem; }
        .sa-panel { border: 1px solid var(--border-color); border-radius: 0.5rem; overflow: hidden; }
        .sa-panel-header { padding: 0.75rem 1rem; background: var(--bg-secondary); font-weight: 500; font-size: 0.875rem; }
        .sa-panel .sa-list { padding: 0.75rem 1rem; max-height: 200px; overflow-y: auto; font-size: 0.8125rem; font-family: 'SF Mono', Monaco, 'Courier New', monospace; }
        .sa-panel .sa-list div { padding: 0.125rem 0; color: var(--text-secondary); }
        .error { text-align: center; padding: 2rem; color: var(--color-bad); background: #fef2f2; border-radius: 0.5rem; }
        .loading { text-align: center; padding: 3rem; color: var(--text-secondary); }
        .framework-selector { display: inline-flex; gap: 0.5rem; margin-bottom: 1rem; }
        .framework-selector button { padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: 500; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 id="page-title">PHP CMS Core Metrics</h1>
            <div class="framework-selector">
                <button id="btn-drupal" class="active" data-framework="drupal">Drupal</button>
                <button id="btn-typo3" data-framework="typo3">TYPO3</button>
            </div>
            <p class="header-meta" id="last-updated">Loading...</p>
            <p class="executive-summary" id="summary-1">The charts below tell the story of a changing code base.</p>
            <p class="executive-summary" id="summary-2"></p>
            <p class="executive-summary" id="summary-3">By tracking these metrics, we hope to inform decisions about both code quality and developer experience.</p>
        </header>
        <div id="dashboard"><div class="loading">Loading data...</div></div>
    </div>
    <script>
        const colors = { production: '#3b82f6', percentile: '#f97316', test: '#8b5cf6' };

        // Framework configurations
        const frameworkConfig = {
            drupal: {
                name: 'Drupal',
                dataFile: 'data/drupal.json',
                repoUrl: 'https://git.drupalcode.org/project/drupal',
                corePrefix: 'core/',
                releases: [
                    { name: 'D7', dates: ['2011-01'] },
                    { name: 'D8', dates: ['2015-10', '2015-11', '2016-01'] },
                    { name: 'D9', dates: ['2020-04', '2020-07'] },
                    { name: 'D10', dates: ['2022-10', '2023-01'] },
                    { name: 'D11', dates: ['2024-07', '2024-10'] }
                ],
                summary: 'Code quality has improved since Drupal 7: lower complexity, fewer anti-patterns, better architecture, and better test coverage. The API surface has also modernized: global functions were replaced by interface methods, services, plugins, and events, shifting from procedural to object-oriented patterns.',
                antipatternDesc: {
                    title: 'Drupal anti-patterns',
                    intro: 'Code patterns with known downsides. Shows how often these patterns appear per 1,000 lines of code (density). PHP production code only; excludes tests and vendor dependencies.',
                    items: [
                        { name: 'Magic keys', desc: '#-prefixed array keys require memorization and lack IDE support. Inherent to Drupal\'s render array architecture.' },
                        { name: 'Deep arrays', desc: 'arrays nested 3+ levels deep are hard to read and refactor.' },
                        { name: 'Service locators', desc: '<code>\\Drupal::service()</code> calls hide dependencies and hinder testing.' }
                    ]
                }
            },
            typo3: {
                name: 'TYPO3',
                dataFile: 'data/typo3.json',
                repoUrl: 'https://github.com/TYPO3/typo3',
                corePrefix: 'typo3/sysext/',
                releases: [
                    { name: 'v8', dates: ['2016-01', '2016-07'] },
                    { name: 'v9', dates: ['2018-07', '2018-10'] },
                    { name: 'v10', dates: ['2020-01', '2020-04'] },
                    { name: 'v11', dates: ['2021-07', '2021-10'] },
                    { name: 'v12', dates: ['2022-07', '2022-10'] },
                    { name: 'v13', dates: ['2024-01', '2024-04'] }
                ],
                summary: 'TYPO3 has evolved from a monolithic PHP application to a modern Symfony-based CMS. The transition to dependency injection, PSR standards, and event-driven architecture represents a significant modernization of the codebase.',
                antipatternDesc: {
                    title: 'TYPO3 anti-patterns',
                    intro: 'Code patterns with known downsides. Shows how often these patterns appear per 1,000 lines of code (density). PHP production code only; excludes tests and vendor dependencies.',
                    items: [
                        { name: 'TCA nesting', desc: 'Type Configuration Arrays nested 3+ levels deep are hard to read and refactor.' },
                        { name: 'Deep arrays', desc: 'arrays nested 3+ levels deep are hard to read and refactor.' },
                        { name: 'Service locators', desc: '<code>GeneralUtility::makeInstance()</code> calls bypass dependency injection.' }
                    ]
                }
            }
        };

        let currentFramework = 'drupal';
        let currentData = null;

        // Plugin to draw threshold bands and release markers
        const thresholdBandsPlugin = {
            id: 'thresholdBands',
            beforeDraw: (chart) => {
                const { ctx: context, chartArea, scales, options } = chart;
                const metric = options.plugins?.thresholdBands?.metric;
                if (!chartArea) return;

                const yScale = scales.y;
                const xScale = scales.x;
                const { left, right, top, bottom } = chartArea;

                context.save();
                context.beginPath();
                context.rect(left, top, right - left, bottom - top);
                context.clip();

                if (metric === 'ccn') {
                    const y6 = yScale.getPixelForValue(6);
                    const y10 = yScale.getPixelForValue(10);
                    context.fillStyle = 'rgba(34, 197, 94, 0.15)';
                    context.fillRect(left, y6, right - left, bottom - y6);
                    context.fillStyle = 'rgba(245, 158, 11, 0.15)';
                    context.fillRect(left, y10, right - left, y6 - y10);
                    context.fillStyle = 'rgba(239, 68, 68, 0.15)';
                    context.fillRect(left, top, right - left, y10 - top);
                } else if (metric === 'mi') {
                    const y85 = yScale.getPixelForValue(85);
                    const y65 = yScale.getPixelForValue(65);
                    context.fillStyle = 'rgba(34, 197, 94, 0.15)';
                    context.fillRect(left, top, right - left, y85 - top);
                    context.fillStyle = 'rgba(245, 158, 11, 0.15)';
                    context.fillRect(left, y85, right - left, y65 - y85);
                    context.fillStyle = 'rgba(239, 68, 68, 0.15)';
                    context.fillRect(left, y65, right - left, bottom - y65);
                } else if (metric === 'antipatterns') {
                    const y20 = yScale.getPixelForValue(20);
                    const y40 = yScale.getPixelForValue(40);
                    context.fillStyle = 'rgba(34, 197, 94, 0.15)';
                    context.fillRect(left, y20, right - left, bottom - y20);
                    context.fillStyle = 'rgba(245, 158, 11, 0.15)';
                    context.fillRect(left, y40, right - left, y20 - y40);
                    context.fillStyle = 'rgba(239, 68, 68, 0.15)';
                    context.fillRect(left, top, right - left, y40 - top);
                }

                const labels = chart.data.labels || [];
                const releases = frameworkConfig[currentFramework].releases;

                releases.forEach((release) => {
                    const index = labels.findIndex(label => release.dates.includes(label));
                    if (index >= 0) {
                        const x = xScale.getPixelForValue(index);
                        context.strokeStyle = 'rgba(100, 116, 139, 0.4)';
                        context.lineWidth = 1;
                        context.setLineDash([4, 4]);
                        context.beginPath();
                        context.moveTo(x, top);
                        context.lineTo(x, bottom);
                        context.stroke();
                        context.setLineDash([]);

                        context.fillStyle = 'rgba(100, 116, 139, 0.7)';
                        context.font = '10px -apple-system, sans-serif';
                        context.fillText(release.name, x + 3, top + 12);
                    }
                });

                context.restore();
            }
        };
        Chart.register(thresholdBandsPlugin);

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function getCommitUrl(hash) {
            const config = frameworkConfig[currentFramework];
            return `${config.repoUrl}/-/commit/${hash}`;
        }

        function getFileUrl(file) {
            const config = frameworkConfig[currentFramework];
            return `${config.repoUrl}/-/blob/HEAD/${config.corePrefix}${file}`;
        }

        function createLocChart(container, data, title, subtitle) {
            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>${title}</h2><p class="section-subtitle">${subtitle}</p><div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...data].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'Production code', data: sortedData.map(d => d.production?.loc || 0), borderColor: colors.production, backgroundColor: colors.production, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'circle' },
                        { label: 'Tests', data: sortedData.map(d => d.testLoc || 0), borderColor: colors.test, backgroundColor: colors.test, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rect', borderDash: [5, 5], hidden: true }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: tooltipContext => `${tooltipContext.dataset.label}: ${tooltipContext.parsed.y.toLocaleString()}`
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: {
                            min: 0,
                            grid: { color: '#e2e8f0' }
                        }
                    }
                }
            });
        }

        function createCcnChart(container, data) {
            const ccnData = data.filter(d => d.production?.ccn?.avg !== undefined);
            if (ccnData.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Cyclomatic complexity (CCN)</h2>
                <p class="section-subtitle"><a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic complexity</a> measures decision paths per function. The average shows typical complexity, while the 95th percentile reveals the worst 5% of functions. Green (&lt;6) simple, yellow (6-10) moderate, red (&gt;10) complex. PHP production code only; excludes tests and vendor dependencies.</p>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...ccnData].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'Average', data: sortedData.map(d => d.production?.ccn?.avg || 0), borderColor: colors.production, backgroundColor: colors.production, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'circle' },
                        { label: '95th percentile', data: sortedData.map(d => d.production?.ccn?.p95 || 0), borderColor: colors.percentile, backgroundColor: colors.percentile, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rect', borderDash: [5, 5] }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12
                        },
                        thresholdBands: { metric: 'ccn' }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: {
                            min: 0,
                            grid: { color: '#e2e8f0' },
                            title: { display: true, text: 'CCN' }
                        }
                    }
                }
            });
        }

        function createMiChart(container, data) {
            const miData = data.filter(d => d.production?.mi?.avg !== undefined);
            if (miData.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Maintainability index (MI)</h2>
                <p class="section-subtitle"><a href="https://www.verifysoft.com/en_maintainability.html">Maintainability index</a> (0-100). The average shows typical maintainability, while the 5th percentile reveals the least maintainable 5% of functions. Green (&gt;85) highly maintainable, yellow (65-85) moderate, red (&lt;65) difficult to maintain. PHP production code only; excludes tests and vendor dependencies.</p>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...miData].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            new Chart(context, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        { label: 'Average', data: sortedData.map(d => d.production?.mi?.avg || 0), borderColor: colors.production, backgroundColor: colors.production, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'circle' },
                        { label: '5th percentile', data: sortedData.map(d => d.production?.mi?.p5 || 0), borderColor: colors.percentile, backgroundColor: colors.percentile, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rect', borderDash: [5, 5] }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12
                        },
                        thresholdBands: { metric: 'mi' }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: {
                            min: 0,
                            max: 100,
                            grid: { color: '#e2e8f0' },
                            title: { display: true, text: 'MI' }
                        }
                    }
                }
            });
        }

        function renderHotspots(container, snapshots) {
            const snapshotsWithHotspots = snapshots.filter(s => s.hotspots?.length);
            if (!snapshotsWithHotspots.length) return;

            const sortedSnapshots = [...snapshotsWithHotspots].sort((a, b) => b.date.localeCompare(a.date));
            let currentSnapshot = sortedSnapshots[0];
            let currentSort = 'ccn';
            const maxShow = 50;
            const initialShow = 15;
            let expanded = false;

            const sortFunctions = {
                ccn: (a, b) => (b.ccn || 0) - (a.ccn || 0),
                mi: (a, b) => (a.mi || 100) - (b.mi || 100),
                antipatterns: (a, b) => (b.antipatterns || 0) - (a.antipatterns || 0)
            };

            const makeRow = (hotspot, index) => {
                const fileUrl = hotspot.file ? getFileUrl(hotspot.file) : '#';
                return `
                    <tr>
                        <td>${index + 1}</td>
                        <td class="class-name"><a href="${fileUrl}" title="${escapeHtml(hotspot.file)}">${escapeHtml(hotspot.name)}</a></td>
                        <td class="${hotspot.ccn > 50 ? 'metric-bad' : hotspot.ccn > 20 ? 'metric-warning' : ''}">${hotspot.ccn}</td>
                        <td class="${hotspot.mi < 50 ? 'metric-bad' : hotspot.mi < 80 ? 'metric-warning' : 'metric-good'}">${hotspot.mi}</td>
                        <td class="${hotspot.antipatterns > 20 ? 'metric-bad' : hotspot.antipatterns > 10 ? 'metric-warning' : ''}">${hotspot.antipatterns || '—'}</td>
                    </tr>
                `;
            };

            const renderTable = () => {
                const hotspots = currentSnapshot.hotspots || [];
                const sorted = [...hotspots].sort(sortFunctions[currentSort]).slice(0, maxShow);
                const showCount = expanded ? sorted.length : Math.min(initialShow, sorted.length);
                const tableBody = document.getElementById('hotspots-tbody');
                tableBody.innerHTML = sorted.slice(0, showCount).map(makeRow).join('');

                document.querySelectorAll('.sort-button').forEach(button => {
                    button.classList.toggle('active', button.dataset.sort === currentSort);
                });

                const toggleButton = document.getElementById('toggle-hotspots');
                if (toggleButton) {
                    toggleButton.textContent = expanded ? 'Show fewer' : `Show all ${sorted.length} hotspots`;
                    toggleButton.style.display = sorted.length > initialShow ? 'inline-block' : 'none';
                }
            };

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `
                <h2>Complexity hotspots</h2>
                <p class="section-subtitle">
                    Snapshot:
                    <select id="hotspots-snapshot-select" style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 0.875rem; margin-left: 0.25rem;">
                        ${sortedSnapshots.map((s, i) => `<option value="${s.date}">${s.date}${i === 0 ? ' (current)' : ''}</option>`).join('')}
                    </select>
                    <span style="margin-left: 1rem;">Sort by:</span>
                    <button class="sort-button active" data-sort="ccn">CCN</button>
                    <button class="sort-button" data-sort="mi">MI</button>
                    <button class="sort-button" data-sort="antipatterns">Anti-patterns</button>
                </p>
                <table class="hotspots-table">
                    <thead><tr><th>#</th><th>Function</th><th>CCN</th><th>MI</th><th>Anti-patterns</th></tr></thead>
                    <tbody id="hotspots-tbody"></tbody>
                </table>
                <button id="toggle-hotspots" class="toggle-button">Show all</button>
            `;
            container.appendChild(section);

            section.querySelector('#hotspots-snapshot-select').addEventListener('change', function(e) {
                currentSnapshot = sortedSnapshots.find(s => s.date === e.target.value);
                expanded = false;
                renderTable();
            });

            section.querySelectorAll('.sort-button').forEach(button => {
                button.addEventListener('click', function() {
                    currentSort = this.dataset.sort;
                    renderTable();
                });
            });

            document.getElementById('toggle-hotspots').addEventListener('click', function() {
                expanded = !expanded;
                renderTable();
            });

            renderTable();
        }

        function renderRecentCommits(container, commits) {
            if (!commits || !commits.length) return;

            const section = document.createElement('div');
            section.className = 'card';
            const initialShow = 15;
            let expanded = false;

            const formatDelta = (value) => {
                return value > 0 ? `+${value}` : String(value);
            };

            const makeRow = (commit) => {
                const ccnClass = commit.ccnDelta > 0 ? 'metric-bad' : (commit.ccnDelta < 0 ? 'metric-good' : '');
                const miClass = commit.miDelta < 0 ? 'metric-bad' : (commit.miDelta > 0 ? 'metric-good' : '');
                const antipatternClass = commit.antipatternsDelta > 0 ? 'metric-bad' : (commit.antipatternsDelta < 0 ? 'metric-good' : '');
                return `
                    <tr>
                        <td><a href="${getCommitUrl(commit.hash)}"><code>${commit.hash}</code></a></td>
                        <td>${commit.date}</td>
                        <td>${commit.type}</td>
                        <td>${escapeHtml(commit.message)}</td>
                        <td>${formatDelta(commit.locDelta)}</td>
                        <td class="${ccnClass}">${formatDelta(commit.ccnDelta)}</td>
                        <td class="${miClass}">${formatDelta(commit.miDelta)}</td>
                        <td class="${antipatternClass}">${formatDelta(commit.antipatternsDelta)}</td>
                    </tr>
                `;
            };

            const initialRows = commits.slice(0, initialShow).map(makeRow).join('');
            const hasMore = commits.length > initialShow;
            const toggleButton = hasMore ? `<button id="toggle-commits" class="toggle-button">Show all ${commits.length} commits</button>` : '';

            section.innerHTML = `
                <h2>Recent commits</h2>
                <p class="section-subtitle">Commits that changed code quality metrics. Green = improved, red = worsened.</p>
                <table class="hotspots-table">
                    <thead><tr><th>Commit</th><th>Date</th><th>Type</th><th>Message</th><th>LOC Δ</th><th>CCN Δ</th><th>MI Δ</th><th>Anti-patterns Δ</th></tr></thead>
                    <tbody id="commits-tbody">${initialRows}</tbody>
                </table>
                ${toggleButton}
            `;
            container.appendChild(section);

            if (hasMore) {
                document.getElementById('toggle-commits').addEventListener('click', function() {
                    const tableBody = document.getElementById('commits-tbody');
                    expanded = !expanded;
                    if (expanded) {
                        tableBody.innerHTML = commits.map(makeRow).join('');
                        this.textContent = 'Show fewer commits';
                    } else {
                        tableBody.innerHTML = commits.slice(0, initialShow).map(makeRow).join('');
                        this.textContent = `Show all ${commits.length} commits`;
                    }
                });
            }
        }

        function createAntiPatternsChart(container, data) {
            const patternsData = data.filter(d => d.antipatterns && Object.keys(d.antipatterns).length > 0);
            if (patternsData.length < 2) return;

            const config = frameworkConfig[currentFramework].antipatternDesc;
            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>${config.title}</h2>
                <p class="section-subtitle">${config.intro}</p>
                <ul class="metric-list">
                    ${config.items.map(item => `<li><strong>${item.name}</strong>: ${item.desc}</li>`).join('')}
                </ul>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...patternsData].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            const getDensity = (d, key) => {
                const count = d.antipatterns?.[key] || 0;
                const loc = d.production?.loc || 1;
                return (count / loc) * 1000;
            };

            const antipatternColors = {
                magicKeys: '#ef4444',
                tcaKeys: '#ef4444',
                deepArrays: '#f97316',
                serviceLocators: '#eab308',
                globalsAccess: '#8b5cf6'
            };

            // Build datasets based on available antipattern types
            const datasets = [];
            const firstData = sortedData[0]?.antipatterns || {};

            if ('magicKeys' in firstData) {
                datasets.push({ label: 'Magic keys', data: sortedData.map(d => getDensity(d, 'magicKeys')), borderColor: antipatternColors.magicKeys, backgroundColor: antipatternColors.magicKeys + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 3, pointStyle: 'circle' });
            }
            if ('tcaKeys' in firstData) {
                datasets.push({ label: 'TCA nesting', data: sortedData.map(d => getDensity(d, 'tcaKeys')), borderColor: antipatternColors.tcaKeys, backgroundColor: antipatternColors.tcaKeys + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 3, pointStyle: 'circle' });
            }
            if ('deepArrays' in firstData) {
                datasets.push({ label: 'Deep arrays', data: sortedData.map(d => getDensity(d, 'deepArrays')), borderColor: antipatternColors.deepArrays, backgroundColor: antipatternColors.deepArrays + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rect' });
            }
            if ('serviceLocators' in firstData) {
                datasets.push({ label: 'Service locators', data: sortedData.map(d => getDensity(d, 'serviceLocators')), borderColor: antipatternColors.serviceLocators, backgroundColor: antipatternColors.serviceLocators + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'triangle' });
            }
            if ('globalsAccess' in firstData) {
                datasets.push({ label: 'Globals access', data: sortedData.map(d => getDensity(d, 'globalsAccess')), borderColor: antipatternColors.globalsAccess, backgroundColor: antipatternColors.globalsAccess + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 4, pointStyle: 'rectRot' });
            }

            new Chart(context, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: tooltipContext => `${tooltipContext.dataset.label}: ${tooltipContext.parsed.y.toFixed(1)} per 1k LOC`
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Density (per 1k LOC)' } }
                    }
                }
            });
        }

        function createSurfaceAreaChart(container, data) {
            const surfaceAreaData = data.filter(d => d.surfaceArea && Object.keys(d.surfaceArea).length > 0);
            if (surfaceAreaData.length < 2) return;

            const config = frameworkConfig[currentFramework];
            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>API surface area</h2>
                <p class="section-subtitle">The chart tracks distinct extension points in ${config.name} Core over time. PHP production code only; excludes tests and vendor dependencies.</p>
                <p class="section-subtitle">The chart shows how the architecture has evolved and the types of extension points developers need to learn.</p>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const sortedData = [...surfaceAreaData].sort((a, b) => a.date.localeCompare(b.date));
            const labels = sortedData.map(d => d.date);

            const surfaceAreaColors = {
                globalFunctions: '#06b6d4',
                hooks: '#f97316',
                services: '#3b82f6',
                events: '#22c55e',
                pluginTypes: '#ef4444',
                yamlFormats: '#8b5cf6',
                magicKeys: '#eab308',
                tcaKeys: '#eab308',
                interfaceMethods: '#ec4899'
            };

            // Build datasets based on available surface area types
            const datasets = [];
            const firstData = sortedData[0]?.surfaceArea || {};

            if ('globalFunctions' in firstData) {
                datasets.push({ label: 'Global functions', data: sortedData.map(d => d.surfaceArea?.globalFunctions || 0), borderColor: surfaceAreaColors.globalFunctions, backgroundColor: surfaceAreaColors.globalFunctions + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }
            if ('hooks' in firstData) {
                datasets.push({ label: 'Hooks', data: sortedData.map(d => d.surfaceArea?.hooks || 0), borderColor: surfaceAreaColors.hooks, backgroundColor: surfaceAreaColors.hooks + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }
            if ('services' in firstData) {
                datasets.push({ label: 'Services', data: sortedData.map(d => d.surfaceArea?.services || 0), borderColor: surfaceAreaColors.services, backgroundColor: surfaceAreaColors.services + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }
            if ('events' in firstData) {
                datasets.push({ label: 'Events', data: sortedData.map(d => d.surfaceArea?.events || 0), borderColor: surfaceAreaColors.events, backgroundColor: surfaceAreaColors.events + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }
            if ('pluginTypes' in firstData) {
                datasets.push({ label: 'Plugin types', data: sortedData.map(d => d.surfaceArea?.pluginTypes || 0), borderColor: surfaceAreaColors.pluginTypes, backgroundColor: surfaceAreaColors.pluginTypes + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }
            if ('yamlFormats' in firstData) {
                datasets.push({ label: 'YAML formats', data: sortedData.map(d => d.surfaceArea?.yamlFormats || 0), borderColor: surfaceAreaColors.yamlFormats, backgroundColor: surfaceAreaColors.yamlFormats + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }
            if ('magicKeys' in firstData) {
                datasets.push({ label: 'Magic keys', data: sortedData.map(d => d.surfaceArea?.magicKeys || 0), borderColor: surfaceAreaColors.magicKeys, backgroundColor: surfaceAreaColors.magicKeys + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }
            if ('tcaKeys' in firstData) {
                datasets.push({ label: 'TCA keys', data: sortedData.map(d => d.surfaceArea?.tcaKeys || 0), borderColor: surfaceAreaColors.tcaKeys, backgroundColor: surfaceAreaColors.tcaKeys + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }
            if ('interfaceMethods' in firstData) {
                datasets.push({ label: 'Interface methods', data: sortedData.map(d => d.surfaceArea?.interfaceMethods || 0), borderColor: surfaceAreaColors.interfaceMethods, backgroundColor: surfaceAreaColors.interfaceMethods + '80', fill: true, borderWidth: 2, tension: 0.3, pointRadius: 2 });
            }

            new Chart(context, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { intersect: false, mode: 'index' },
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 10 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                footer: (items) => {
                                    const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                                    return `Total: ${total}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { display: false },
                            ticks: {
                                callback: function(value, index) {
                                    const label = this.getLabelForValue(value);
                                    const year = label.substring(0, 4);
                                    const labels = this.chart.data.labels;
                                    const prevLabel = index > 0 ? labels[index - 1] : '';
                                    if (prevLabel.substring(0, 4) !== year) {
                                        return year;
                                    }
                                    return '';
                                },
                                maxRotation: 0
                            }
                        },
                        y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Total' } }
                    }
                }
            });
        }

        function createCommitsPerYearChart(container, commitsPerYear) {
            if (!commitsPerYear || commitsPerYear.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Commits per year</h2>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const labels = commitsPerYear.map(d => d.year.toString());
            const data = commitsPerYear.map(d => d.commits);

            new Chart(context, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Commits',
                        data,
                        backgroundColor: '#3b82f6',
                        borderColor: '#2563eb',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: (tooltipContext) => `${tooltipContext.parsed.y.toLocaleString()} commits`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: { beginAtZero: true, title: { display: true, text: 'Commits' } }
                    }
                }
            });
        }

        function createCommitsPerMonthChart(container, commitsMonthly) {
            if (!commitsMonthly || commitsMonthly.length < 2) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Commits per month</h2>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const currentYear = new Date().getFullYear();
            const years = [currentYear - 3, currentYear - 2, currentYear - 1, currentYear];
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            const yearColors = ['#cbd5e1', '#94a3b8', '#3b82f6', '#22c55e'];
            const datasets = years.map((year, yearIndex) => {
                const monthData = monthNames.map((_, monthIndex) => {
                    const monthString = String(monthIndex + 1).padStart(2, '0');
                    const dateKey = `${year}-${monthString}`;
                    const found = commitsMonthly.find(d => d.date === dateKey);
                    return found ? found.total : 0;
                });
                return {
                    label: year.toString(),
                    data: monthData,
                    backgroundColor: yearColors[yearIndex],
                    borderColor: yearColors[yearIndex],
                    borderWidth: 1
                };
            });

            new Chart(context, {
                type: 'bar',
                data: {
                    labels: monthNames,
                    datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: (tooltipContext) => `${tooltipContext.dataset.label}: ${tooltipContext.parsed.y.toLocaleString()} commits`
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false } },
                        y: { beginAtZero: true, title: { display: true, text: 'Commits' } }
                    }
                }
            });
        }

        function createCommitTypeDistributionChart(container, commitsMonthly) {
            if (!commitsMonthly || commitsMonthly.length < 2) return;

            const now = new Date();
            const twelveMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 11, 1).toISOString().slice(0, 7);
            const filtered = commitsMonthly.filter(d => d.date >= twelveMonthsAgo);

            if (filtered.length < 1) return;

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `<h2>Features vs tasks vs bugs</h2>
                <p class="section-subtitle">Tasks include both maintenance work (documentation, tests, CI, refactoring) and smaller enhancements. Healthy mature projects allocate 20-40% to features.</p>
                <div class="chart-container"><canvas></canvas></div>`;
            container.appendChild(section);

            const context = section.querySelector('canvas').getContext('2d');
            const labels = filtered.map(d => d.date);

            const getPercent = (d, field) => {
                const total = d.total;
                return total > 0 ? (d[field] / total) * 100 : 0;
            };

            new Chart(context, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Features',
                            data: filtered.map(d => getPercent(d, 'features')),
                            backgroundColor: '#3b82f6',
                            borderColor: '#2563eb',
                            borderWidth: 1
                        },
                        {
                            label: 'Tasks',
                            data: filtered.map(d => getPercent(d, 'maintenance')),
                            backgroundColor: '#60a5fa',
                            borderColor: '#3b82f6',
                            borderWidth: 1
                        },
                        {
                            label: 'Bugs',
                            data: filtered.map(d => getPercent(d, 'bugs')),
                            backgroundColor: '#ef4444',
                            borderColor: '#dc2626',
                            borderWidth: 1
                        },
                        {
                            label: 'Unknown',
                            data: filtered.map(d => getPercent(d, 'unknown')),
                            backgroundColor: '#e2e8f0',
                            borderColor: '#cbd5e1',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, position: 'top', labels: { usePointStyle: true, padding: 15 } },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            callbacks: {
                                label: (tooltipContext) => `${tooltipContext.dataset.label}: ${tooltipContext.parsed.y.toFixed(1)}%`
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            grid: { display: false },
                            ticks: { maxRotation: 0 }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            max: 100,
                            title: { display: true, text: 'Percentage' },
                            ticks: {
                                callback: (value) => value + '%'
                            }
                        }
                    }
                }
            });
        }

        function renderSurfaceAreaReference(container, snapshots) {
            const snapshotsWithLists = snapshots.filter(s => s.surfaceAreaLists && Object.keys(s.surfaceAreaLists).length);
            if (!snapshotsWithLists.length) return;

            const titles = {
                globalFunctions: 'Global functions',
                hooks: 'Hooks',
                services: 'Services',
                events: 'Events',
                pluginTypes: 'Plugin types',
                yamlFormats: 'YAML formats',
                magicKeys: 'Magic keys',
                tcaKeys: 'TCA keys',
                interfaceMethods: 'Interface methods'
            };

            function renderPanels(surfaceAreaLists) {
                return Object.keys(titles)
                    .filter(key => surfaceAreaLists[key])
                    .map(key => {
                        const items = surfaceAreaLists[key];
                        const sorted = [...items].sort();
                        return `
                            <div class="sa-panel">
                                <div class="sa-panel-header">${titles[key]} (${items.length})</div>
                                <div class="sa-list">${sorted.map(item => `<div>${escapeHtml(item)}</div>`).join('')}</div>
                            </div>
                        `;
                    }).join('');
            }

            const sortedSnapshots = [...snapshotsWithLists].sort((a, b) => b.date.localeCompare(a.date));
            const latestSnapshot = sortedSnapshots[0];

            const section = document.createElement('div');
            section.className = 'card';
            section.innerHTML = `
                <h2>API surface details</h2>
                <p class="section-subtitle">
                    Snapshot:
                    <select id="surface-area-snapshot-select" style="padding: 0.25rem 0.5rem; border-radius: 0.25rem; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary); font-size: 0.875rem; margin-left: 0.25rem;">
                        ${sortedSnapshots.map((s, i) => `<option value="${s.date}">${s.date}${i === 0 ? ' (current)' : ''}</option>`).join('')}
                    </select>
                </p>
                <div id="surface-area-panels" class="surface-area-grid">${renderPanels(latestSnapshot.surfaceAreaLists)}</div>
            `;
            container.appendChild(section);

            const select = section.querySelector('#surface-area-snapshot-select');
            const panelsContainer = section.querySelector('#surface-area-panels');
            select.addEventListener('change', (e) => {
                const selectedSnapshot = sortedSnapshots.find(s => s.date === e.target.value);
                if (selectedSnapshot) {
                    panelsContainer.innerHTML = renderPanels(selectedSnapshot.surfaceAreaLists);
                }
            });
        }

        function renderDashboard(data) {
            const container = document.getElementById('dashboard');
            container.innerHTML = '';

            if (!data.snapshots?.length) {
                container.innerHTML = '<div class="error">No data available.</div>';
                return;
            }

            const config = frameworkConfig[currentFramework];
            data.snapshots.sort((a, b) => b.date.localeCompare(a.date));

            createLocChart(container, data.snapshots, 'Lines of code', `${config.name} Core codebase size over time. Measures non-blank, non-comment lines (SLOC). PHP code only; excludes vendor dependencies.`);
            createCcnChart(container, data.snapshots);
            createMiChart(container, data.snapshots);
            createAntiPatternsChart(container, data.snapshots);
            createSurfaceAreaChart(container, data.snapshots);
            renderRecentCommits(container, data.commits);
            renderHotspots(container, data.snapshots);
            createCommitsPerYearChart(container, data.commitsPerYear);
            createCommitsPerMonthChart(container, data.commitsMonthly);
            createCommitTypeDistributionChart(container, data.commitsMonthly);
            renderSurfaceAreaReference(container, data.snapshots);
        }

        function updateHeader(data) {
            const config = frameworkConfig[currentFramework];
            document.getElementById('page-title').textContent = `${config.name} Core Metrics`;
            document.getElementById('summary-2').textContent = config.summary;

            const generated = new Date(data.generated);
            const options = { year: 'numeric', month: 'long', day: '2-digit' };
            document.getElementById('last-updated').textContent =
                'Last updated: ' + generated.toLocaleDateString('en-US', options);
        }

        function loadFramework(framework) {
            currentFramework = framework;
            const config = frameworkConfig[framework];

            // Update button states
            document.querySelectorAll('.framework-selector button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.framework === framework);
            });

            // Show loading
            document.getElementById('dashboard').innerHTML = '<div class="loading">Loading data...</div>';

            fetch(config.dataFile)
                .then(response => {
                    if (!response.ok) throw new Error(`Failed to load ${config.name} data`);
                    return response.json();
                })
                .then(data => {
                    currentData = data;
                    updateHeader(data);
                    renderDashboard(data);
                })
                .catch(error => {
                    document.getElementById('dashboard').innerHTML =
                        `<div class="error">Failed to load data: ${error.message}<br><br>Make sure to run the analyzer first: <code>python3 scripts/analyze.py --framework ${framework}</code></div>`;
                });
        }

        // Framework selector event listeners
        document.querySelectorAll('.framework-selector button').forEach(btn => {
            btn.addEventListener('click', () => loadFramework(btn.dataset.framework));
        });

        // Initial load
        loadFramework('drupal');
    </script>
</body>
</html>
